[
  {
    "id": "1765426967529",
    "title": "未命名面试 63",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "待上传",
    "date": "2025-12-11T04:22"
  },
  {
    "id": "1765425938852",
    "title": "未命名面试 62",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "待上传",
    "date": "2025-12-11T04:05"
  },
  {
    "id": "1765425840833",
    "title": "未命名面试 61",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "已完成",
    "date": "2025-12-11T04:04",
    "fileUrl": "uploads/usr_ed4ebf18/5f572af8-f0c1-4b91-979d-a07377faa216.mp3",
    "fileType": "audio/mpeg",
    "durationSeconds": 645.01551,
    "durationText": "10分45秒",
    "transcriptText": "你好，我是李悦。在对专栏的内容正式学习之前啊，我想先来聊聊如何学习消息队列以及如何学习这门课。从系统之间有通讯需求的那一刻开始呢，就产生了消息队列。它也是最古老的中间件之一。消息队列的应用场景啊非常广泛。分布式系统中的很多进程间通信的问题，你都可以用消息队列来解决。可以说啊消息队列是所有的后端程序员必备的技能，但是啊想要系统的。😊深入的学习消息队列也不太容易。在市面上消息队列的论坛啊、社区啊都不少。但是啊信息错综混杂，你想要了解消息队列完整的知识体系，想要深度的进阶成为消息队列的达人，却没有清晰的学习路。"
  },
  {
    "id": "1765425122810",
    "title": "未命名面试 60",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "已完成",
    "date": "2025-12-11T03:52",
    "fileUrl": "uploads/usr_ed4ebf18/2e2c536e-3d05-4890-97dd-db53362de265.mp3",
    "fileType": "audio/mpeg",
    "durationSeconds": 645.01551,
    "durationText": "10分45秒",
    "transcriptText": "你好，我是李悦。在对专栏的内容正式学习之前啊，我想先来聊聊如何学习消息队列以及如何学习这门课。从系统之间有通讯需求的那一刻开始呢，就产生了消息队列，它也是最古老的中间件之一。消息队列的应用场景啊非常广泛。分布式系统中的很多进程间通信的问题，你都可以用消息队列来解决。可以说啊消息队列是所有的后端程序员必备的技能，但是啊想要系统的。😊深入的学习消息队列也不太容易。在市面上消息队列的论坛啊、社区啊都不少。但是啊信息错综混杂，你想要了解消息队列完整的知识体系，想要深度的进阶成为消息队列的达人，却没有清晰的学习路。"
  },
  {
    "id": "1765424481521",
    "title": "未命名面试 59",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "已上传文件",
    "date": "2025-12-11T03:41",
    "fileUrl": "uploads/usr_ed4ebf18/3627cbff-2170-45a6-aabb-cee9d9d30fd0.mp3",
    "fileType": "audio/mpeg",
    "durationSeconds": 839.57551,
    "durationText": "14分",
    "transcriptText": "你好，我是李悦。上节课啊我们讲了如何来确保消息不丢。那课后呢我给你留了一个思考题，让你想一下，如果说消息重复了应该怎么办。那这节课呢我们就来聊一聊如何来处理重复消息的问题。。在消息传递的过程中啊，如果出现了传递失败，发送方呢他会执行重试，那重试的过程中就可能会产生重复消息。对使用消息对列的业务系统来说啊，如果你没有对重复的消息进行处理，那就有可能会导致系统出现数据错误。比如说啊一个消费订单消息统计下单金额服务的微服务。如果他没有正确的处理这个重复消息，那就会出现重复统计，导致这个统计结果错误。那你可能。会问啊，如果消息队列本身能保证消息不重复，那应用程序的实现不就简单了吗？那有没有消息队列能够保证消息不重复呢？关于这个问题啊，我们可以先看一下MQTT协议它是如何界定的。在MQTT协议里边啊，它给出了三种传递消息的时候，能够提供的服务质量标准。这三种服务质量标准从低到高，依次是至多一次至少一次以及恰好一次。我来分别解释一下啊，首先是至多一次。那在MQTT里边呢被称为。most once意思是啊，消息在传递的时候最多会被送达一次。那换一个说法就是没有什么消息可靠性保证他允许丢消息。一般啊都是一些对消息可靠性要求不太高的监控场景。比如说啊我每分钟上报一次机房温度数据，那它是可以接受少量数据丢失的。然后啊我们看一下至少一次这个标准，也就是at least once消息在传递的时候啊，至少会被送达一次，也就是说啊它不允许丢消息，但是允许呢有少量的重复消息出现，最后啊也就是最高的等级，就是恰好一次exactly once。那消息在传递的时候呢，只会被送达一次，不允许丢失，也不允许重复这个标准啊，它不仅仅适用于MQTT啊。那对于所有的消息队列啊，它都是适用的。我们现在常用的绝大部分的消息队列，它提供的服务质量标准啊都是at least once。那包括rocket mQrabbit mQ和卡夫卡都是这样的。也就是说啊，消息队列，它很难保证消息不重复。说到这儿啊，我知道肯定有同学会反驳我我说你说的不对，我看过卡夫卡的文档，卡夫卡呢它是支持exactly once的那我在这里呢跟这些同学解释一下啊，你说的没错，卡夫卡呢的确是支持exactly once。但是啊我讲的也没有问题，为什么这么说呢？卡夫卡它支持的exactly once啊和我们刚刚提到的消息传递的服务质量标准中的exactly once啊，它是不一样的。它是卡夫卡提供的另外一个特性。Yeah.卡普卡中啊支持的事物也和我们通常意义理解的事物啊有一定差异。在卡普卡里边啊，事物和exactly once，它主要是为了配合流计算而使用的特性。我们在专栏的进阶篇这个模块里边啊，会有专门的一节课来讲卡普卡的事物和它支持的exactly once的特性。说到这里啊，稍微说一些题外话，卡普卡的团队啊是一个非常善于包装和营销的团队。你看它很巧妙的利用了两个所有人都熟悉的概念。事物。exactly once来包装它的新特性。实际上它实现的这个事物和exactly once啊，并不是我们通常理解的那两个特性。但是啊你深入了解开发的事物和exly once之后呢，你会发现啊，其实它这个特性啊，虽然跟我们通常理解的这个不太一样。但是啊确实和事物和exly once呢有一定关系，这一点上啊我们都要学习开发团队啊，那一个优秀的开发团队啊，你不仅要能写代码，那你更要能写文档，还能写PPT还要。😊能讲会分享。对于每个程序人来说啊，要求也是一样的。我们把话题收回来啊，继续来说重复消息的问题。既然啊你消息队列啊不能保证消息不重复，那就需要我们的消费代码能够接受消息是有可能重复这个现状。然后啊通过一些方法来消除重复消息对业务的影响。一般解决重复消息的办法是啊，在消费端啊让我们消费消息的这个操作啊具有密等性。密等这个词啊，本来它是一个数学上的概念，有明确的数学定义。那这个定义呢是个数学公式，我就不念了。听音频的同学啊，可以听完之后啊，再看一下这个公式。这个概念啊被拓展到计算机的领域，被用来描述一个操作方法或者服务。一个密等操作，它的特点是任意多次执行所产生的影响，均与一次执行产生的影响一样。通俗的说啊，一个密等的方法，我们使用同样的参数，对它进行多次的调用和一次调用，那对系统产生的影响应该是一样的。所以啊对于密等的方法不用担心重复执行，会对系统造。任何改变。我们来举个例子说明一下啊，在不考虑并发的情况下，把账户X的余额设置为100元。这个操作它执行一次以后啊，对系统的影响是账户X的余额变成100元了。那只要这个参数100元不变啊。那即使再执行多少次。那你账户X，它的余额始终都是100元，不会变化。那这个操作呢，它就是一个密等的操作，我再给你举一个不是密等的例子啊，把账户X。的余额加100元。注意啊，这个例子里边啊是加100元，不是设置为100元。那这个操作呢它就不是密等的。我们每执行一次啊，你的账户余额呢，它就会多100元，那执行多次和执行一次，对系统的影响，也就是账户余额它是不一样的。如果说啊我们系统消费消息的业务逻辑具备密等性，那就不用担心重复消息的问题。因为啊同一条消息啊，消费一次和消费多次，那对系统的影响。讲是完全一样的那也就可以认为啊消费多次啊等于消费一次。从对系统的影响结果来说啊，这个act least once加上密等消费啊，就等于是exactly once。那到底怎么来实现这个密等呢？最好的方法啊，其实是你从业务逻辑上入手，把消费的业务逻辑啊设计成天然幂等的。😊あ。但是啊不是所有的业务逻辑啊，都能设计成天然密等的。这里面啊就需要一些方法和技巧来实现密等。下面啊我给你介绍几种常用的设计密等操作的方法。那第一种方法就是啊利用数据库的约束来实现密等。比如说啊我刚刚提到的那个不具备密等特性的转账的例子，把账户X的余额加100元。我们可以这样来改造这个业务逻辑啊，让它具备密等性。首先啊我们可以限定对于每一个转账单。.每一个账户它只能执行一次变更操作。那在分布式系统里边呢，这个限制的实现方法非常多。最简单的方法是我们在数据库里边啊建一张转账流水表。这个表呢有三个字段，第一个字段呢是转账单ID第二个字段呢是账户ID第三个字段呢是变更的金额。然后啊我们给转账单ID和账户ID这两个字段联合起来，创建一个唯一约束。这样对于相同的转账单ID和账。用户ID表里边呢最多只能存在一条记录。然后啊我们可以把消费消息的业务逻辑啊变成这样。我们现在转账的流水表里边呢加一条转账记录，然后啊再根据转账记录里边记录的转账金额，一步的来操作更新用户的余额就可以了。那在转账流水表里边增加一条转账记录这个操作，由于啊我们在这个表里边预先定义了唯一的约束。那对于同一个转账单，同一个账户，它只能查。入一条记录，那后续重复的插入操作呢都会失败。这样呢就实现了一个密等的操作。我们只要写一个 circlecle，正确的实现它的就可以了。基于这个思路啊，不光可以使用关型数据库。只要是支持类似insertif not exist语义的这类存储系统都可以用来实现密等。比如说啊你可以用radis的s NX命令来替代数据库的唯一约束，实现这个消费密等。另外一个实现密等的思路啊，它是这样的。.我们可以给数据变更呢设置一个前置条件，只有满足条件的时候呢，才更新数据，否则呢就拒绝更新这个数据。同时啊我们在更新数据的时候呢，会变更这个前置条件需要判断的数据。这样啊在重复执行这个操作的时候啊，由于第一次更新数据的时候呢，已经变更了这个前置条件中需要判断的数据。那不满足前置条件呢，这个重复执行呢就不会更新数据。比如啊我们刚刚说过啊，把账户X的余额加。加100元这个操作啊，它本来是不具备密等的特性的那我们呢可以把这个操作给它加一个前置条件，变成如果账户X当前的余额为500元，那就给它的余额加上100元。这个操作啊它就具备密等性。对应到消息队列使用的时候啊，可以在发消息的时候呢，在消息体中带上当前的余额，那在消费的时候呢，判断数据库中，当前的余额是否与消息体中的余额一样。只有相等的时候啊，才执行变更操作。那如果我们要更新的数据啊，它不是一个数值，或者说我们要做一个比较复杂的更新操作的时候怎么办呢？那用什么来做这个前置的判断条件呢？那更加通用的方法是这样的。你可以啊给你的数据啊增加一个版本号的属性。那每次在更新这个数据之前呢，比较一下当前数据的版本号是否和消息中带的这个版本号一样。如果一样呢，就可以更新。那如果不一样呢，就拒绝更新这个数据。并且啊更新数据的同时啊，你要把这个版本号加一，这样一样可以实现密等更新。嗯。如果啊上面提到的这两种密等方法，都不能适用于你的场景啊。我们还有一种通用性最强、适用范围最广的密等方法。那这种方法呢叫记录并检查操作，那也称为token机制，或者是全局为EID的机制。Yeah。实现的思路呢也很简单。那你在执行数据更新操作之前呢，先检查一下是否执行过这个更新操作就可以了。具体的实验方法是这样的，在发消息的时候啊，给每一个消息指定一个全局唯一的ID那在消费的时候呢，先根据这个ID来检查一下这条消息啊，有没有被消费过。如果说没有被消费过呢，你才去执行这个数据更新。同时呢把这个消费状态呢设置为已消费这个原理和实现是不是很简单啊。其实一点儿都不简单，在分布式系统中啊，这个方法其实是非常难实现的。首先啊给每个消息指定一个全局为1ID这件事啊就不太容易。虽然啊方法有很多，但是啊都不太好，同时的满足简单、高可用和高性能，或多或少的都会有些牺牲，这还不是更麻烦的，更麻烦的是什么啊，就是啊检查消费状态，然后更新数据，并且啊设置消费状态，这个过程中啊。😊这三个步骤啊，它必须作为一种操作来保证原子性，才能真正的实现密等，否则啊就会出现bug。比如说啊对于一条消息，它的全局ID为8，那它的操作呢是给ID为666的账户增加100元。あ。那有可能就会出现这样的情况。在T0时刻啊，消费者A他收到了这条消息，然后呢，他去检查消费执行的状态，发现这个状态呢是未处理。然后呢，他开始执行账户增加100元这个操作到了T一时刻啊，消费者B啊又收到了这条消息，然后呢，他去检查执行状态，发现呢还是未处理过。因为这个时刻啊，消费者A还没来得及更新这个消息执行状态。。这样就会导致账户啊被错误的增加了两次100元。这个呢是在分布式系统中啊非常容易犯的错误。那你一定要引以为戒。对以这个问题啊，当然啊我们还可以用事物来实现，也可以用锁来实现。但是啊在分布式系统中啊，无论是分布式事务还是分布式锁啊，都是比较难解决的问题。好的，这就是今天的全部内容，我来总结一下啊，这节课啊我们主要介绍了通过密等消费来解决重复消息的问题。😊Yeah。然后呢，我重点讲了几种实现密等操作的方法，你可以利用数据库的约束来防止重复的更新数据，也可以呢为数据更新设置一个一次性的前置条线来防止重复消息。如果说啊这两种方法都不适用，你还可以用记录并检查操作这种方法来保证密等。这种方法呢适用范围最广，但是呢实现难度和复杂度呢也比较高，一般来说啊不推荐你使用。那这些实现密等的方法不仅可以。用来解决重复消费的问题，也同样适合用于其他的场景中来解决重复请求或者是重复调用的问题。比如说啊我们可以把HTTP服务啊设计成密等的，解决前端或者app重复提交表单数据的问题，也可以将一个微服务设计成密等的，来解决RPC框架，它会自动重试，导致重复调用的问题，这些方法都是通用的，希望你能做到触类旁通，举一反三。最后请你想一下，为什么大部分的消息队列啊，它都。选择只提供at least once的服务质量，而不是级别更高的exactly once呢。欢迎你在留言区与我分享和讨论，感谢你的聆听。如果你觉得这篇文章对你有帮助的话，也欢。😊"
  },
  {
    "id": "1765424390919",
    "title": "未命名面试 58",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "已完成",
    "date": "2025-12-11T03:39",
    "fileUrl": "uploads/usr_ed4ebf18/7e84c607-bf9a-4891-92ad-64c4cf41d208.mp3",
    "fileType": "audio/mpeg",
    "durationSeconds": 839.57551,
    "durationText": "14分",
    "transcriptText": "你好，我是李悦。上节课啊我们讲了如何来确保消息不丢。那课后呢我给你留了一个思考题，让你想一下，如果说消息重复了应该怎么办。那这节课呢我们就来聊一聊如何来处理重复消息的问题。Yeah.在消息传递的过程中啊，如果出现了传递失败，发送方呢他会执行重试，那重试的过程中就可能会产生重复消息。对使用消息对列的业务系统来说啊，如果你没有对重复的消息进行处理，那就有可能会导致系统出现数据错误。比如说啊一个消费订单消息统计下单金额服务的微服务。如果他没有正确的处理这个重复消息，那就会出现重复统计，导致这个统计结果错误。那你可能。会问啊，如果消息队列本身能保证消息不重复，那应用程序的实现不就简单了吗？那有没有消息队列能够保证消息不重复呢？关于这个问题啊，我们可以先看一下MQTT协议它是如何界定的。在MQTT协议里边啊，它给出了三种传递消息的时候，能够提供的服务质量标准。这三种服务质量标准从低到高，依次是至多一次至少一次以及恰好一次。我来分别解释一下啊，首先是至多一次。那在MQTT里边呢被称为。most once意思是啊，消息在传递的时候最多会被送达一次。那换一个说法就是没有什么消息可靠性保证他允许丢消息。一般啊都是一些对消息可靠性要求不太高的监控场景。比如说啊我每分钟上报一次机房温度数据，那它是可以接受少量数据丢失的。然后啊我们看一下至少一次这个标准，也就是at least once消息在传递的时候啊，至少会被送达一次，也就是说啊它不允许丢消息，但是允许呢有少量的重复消息出现，最后啊也就是最高的等级，就是恰好一次exactly once。那消息在传递的时候呢，只会被送达一次，不允许丢失，也不允许重复这个标准啊，它不仅仅适用于MQTT啊。那对于所有的消息队列啊，它都是适用的。我们现在常用的绝大部分的消息队列，它提供的服务质量标准啊都是at least once。那包括rocket mQrabbit mQ和卡夫卡都是这样的。也就是说啊，消息队列，他很难保证消息不重复。说到这儿啊，我知道肯定有同学会反驳我我说你说的不对，我看过卡夫卡的文档，卡夫卡呢它是支持exactly once的那我在这里呢跟这些同学解释一下啊，你说的没错，卡夫卡呢的确是支持exactly once。但是啊我讲的也没有问题，为什么这么说呢？卡夫卡它支持的exactly once啊和我们刚刚提到的消息传递的服务质量标准中的exactly once啊，它是不一样的。它是卡夫卡提供的另外一个特性。Yeah.卡普卡中啊支持的事物也和我们通常意义理解的事物啊有一定差异。在卡普卡里边啊，事物和exactly once，它主要是为了配合流计算而使用的特性。我们在专栏的进阶篇这个模块里边啊，会有专门的一节课来讲卡普卡的事物和它支持的exactly once的特性。说到这里啊，稍微说一些题外话。卡夫卡的团队啊是一个非常善于包装和营销的团队。你看它很巧妙的利用了两个所有人都熟悉的概念。事物。exactly once来包装它的新特性。实际上它实现的这个事物和exactly once啊，并不是我们通常理解的那两个特性。但是啊你深入了解开发的事物和exly once之后呢，你会发现啊，其实它这个特性啊，虽然跟我们通常理解的这个不太一样。但是啊确实和事物和exly once呢有一定关系，这一点上啊我们都要学习开发团队啊，那一个优秀的开发团队啊，你不仅要能写代码，那你更要能写文档，还能写PPT还要。😊能讲会分享。对于每个程序人来说啊，要求也是一样的。我们把话题收回来啊，继续来说重复消息的问题。既然啊你消息队列啊不能保证消息不重复，那就需要我们的消费代码能够接受消息是有可能重复这个现状。然后啊通过一些方法来消除重复消息对业务的影响。一般解决重复消息的办法是啊，在消费端啊让我们消费消息的这个操作啊具有密等性。密等这个词啊，本来它是一个数学上的概念，有明确的数学定义。那这个定义呢是个数学公式，我就不念了。听音频的同学啊，可以听完之后啊，再看一下这个公式。这个概念啊被拓展到计算机的领域，被用来描述一个操作方法或者服务。一个密等操作，它的特点是任意多次执行所产生的影响，均与一次执行产生的影响一样。通俗的说啊，一个密等的方法，我们使用同样的参数，对它进行多次的调用和一次调用，那对系统产生的影响应该是一样的。所以啊对于密等的方法不用担心重复执行，会对系统造。任何改变。我们来举个例子说明一下啊，在不考虑并发的情况下，把账户X的余额设置为100元。这个操作它执行一次以后啊，对系统的影响是账户X的余额变成100元了。那只要这个参数100元不变啊。那即使再执行多少次。那你账户X，它的余额始终都是100元，不会变化。那这个操作呢，它就是一个密等的操作，我再给你举一个不是密等的例子啊，把账户X。的余额加100元。注意啊，这个例子里边啊是加100元，不是设置为100元。那这个操作呢它就不是密等的。我们每执行一次啊，你的账户余额呢它就会多100元，那执行多次和执行一次，对系统的影响，也就是账户余额它是不一样的。如果说啊我们系统消费消息的业务逻辑具备密等性，那就不用担心重复消息的问题。因为啊同一条消息啊，消费一次和消费多次，那对系统的影响。讲是完全一样的那也就可以认为啊消费多次啊等于消费一次。从对系统的影响结果来说啊，这个act least once加上密等消费啊，就等于是exactly once。那到底怎么来实现这个密等呢？最好的方法啊，其实是你从业务逻辑上入手，把消费的业务逻辑啊设计成天然幂等的。😊あ。但是啊不是所有的业务逻辑啊，都能设计成天然密等的。这里面啊就需要一些方法和技巧来实现密等。下面啊我给你介绍几种常用的设计密等操作的方法。那第一种方法就是啊利用数据库的约束来实现密等。比如说啊我刚刚提到的那个不具备密等特性的转账的例子，把账户X的余额加100元。我们可以这样来改造这个业务逻辑啊，让它具备密等性。首先啊我们可以限定对于每一个转账单。？每一个账户它只能执行一次变更操作。那在分布式系统里边呢，这个限制的实现方法非常多。最简单的方法是我们在数据库里边啊建一张转账流水表。这个表呢有三个字段，第一个字段呢是转账单ID第二个字段呢是账户ID第三个字段呢是变更的金额。然后啊我们给转账单ID和账户ID这两个字段联合起来，创建一个唯一约束。这样对于相同的转账单ID和账。用户ID表里边呢最多只能存在一条记录。然后啊我们可以把消费消息的业务逻辑啊变成这样。我们现在转账的流水表里边呢加一条转账记录。然后啊再根据转账记录里边记录的转账金额，一步的来操作更新用户的余额就可以了。那在转账流水表里边增加一条转账记录这个操作，由于啊我们在这个表里边预先定义了唯一的约束。那对于同一个转账单，同一个账户，它只能查。入一条记录，那后续重复的插入操作呢都会失败。这样呢就实现了一个密等的操作。我们只要写一个 circlecle，正确的实现它的就可以了。基于这个思路啊，不光可以使用关型数据库。只要是支持类似insertif not exist语义的这类存储系统都可以用来实现密等。比如说啊你可以用radis的s NX命令来替代数据库的唯一约束，实现这个消费密等。另外一个实现密等的思路啊，它是这样的。。我们可以给数据变更呢设置一个前置条件，只有满足条件的时候呢，才更新数据，否则呢就拒绝更新这个数据。同时啊我们在更新数据的时候呢，会变更这个前置条件需要判断的数据，这样啊在重复执行这个操作的时候啊，由于第一次更新数据的时候呢，已经变更了这个前置条件中需要判断的数据。那不满足前置条件呢，这个重复执行呢就不会更新数据。比如啊我们刚刚说过啊，把账户X的余额加。加100元这个操作啊，它本来是不具备密等的特性的那我们呢可以把这个操作给它加一个前置条件，变成如果账户X当前的余额为500元，那就给它的余额加上100元。这个操作啊它就具备密等性。对应到消息队列使用的时候啊，可以在发消息的时候呢，在消息体中带上当前的余额，那在消费的时候呢，判断数据库中，当前的余额是否与消息体中的余额一样。只有相等的时候啊，才执行变更操作。那如果我们要更新的数据啊，它不是一个数值，或者说我们要做一个比较复杂的更新操作的时候怎么办呢？那用什么来做这个前置的判断条件呢？那更加通用的方法是这样的。你可以啊给你的数据啊增加一个版本号的属性。那每次在更新这个数据之前呢，比较一下当前数据的版本号是否和消息中带的这个版本号一样。如果一样呢，就可以更新。那如果不一样呢，就拒绝更新这个数据。并且啊更新数据的同时啊，你要把这个版本号加一，这样一样可以实现密等更新。Yeah.如果啊上面提到的这两种密等方法，都不能适用于你的场景啊。我们还有一种通用性最强、适用范围最广的密等方法。那这种方法呢叫记录并检查操作，那也称为token机制，或者是全局为EID的机制。Yeah.实现的思路呢也很简单。那你在执行数据更新操作之前呢，先检查一下是否执行过这个更新操作就可以了。具体的实验方法是这样的，在发消息的时候啊，给每一个消息指定一个全局唯一的ID那在消费的时候呢，先根据这个ID来检查一下这条消息啊有没有被消费过。如果说没有被消费过呢，你才去执行这个数据更新。同时呢把这个消费状态呢设置为已消费这个原理和实现是不是很简单啊。其实一点儿都不简单，在分布式系统中啊，这个方法其实是非常难实现的。首先啊给每个消息指定一个全局为1ID这件事啊就不太容易。虽然啊方法有很多，但是啊都不太好，同时的满足简单高可用和高性能，或多或少的都会有些牺牲，这还不是更麻烦的，更麻烦的是什么啊？就是啊检查消费状态，然后更新数据，并且啊设置消费状态，这个过程中啊。😊这三个步骤啊，它必须作为一种操作来保证原子性，才能真正的实现密等，否则啊就会出现bug。比如说啊对于一条消息，它的全局ID为8，那它的操作呢是给ID为666的账户增加100元。あ。那有可能就会出现这样的情况。在T0时刻啊，消费者A他收到了这条消息，然后呢，他去检查消费执行的状态，发现这个状态呢是未处理。然后呢，他开始执行账户增加100元这个操作到了T一时刻啊，消费者B啊又收到了这条消息，然后呢，他去检查执行状态，发现呢还是未处理过。因为这个时刻啊消费者A还没来得及更新这个消息执行状态。。这样就会导致账户啊被错误的增加了两次100元。这个呢是在分布式系统中啊非常容易犯的错误。那你一定要引以为戒。对于这个问题啊，当然啊我们还可以用事物来实现，也可以用锁来实现。但是啊在分布式系统中啊，无论是分布式事务还是分布式锁啊，都是比较难解决的问题。好的，这就是今天的全部内容，我来总结一下啊，这节课啊我们主要介绍了通过密等消费来解决重复消息的问题。😊Yeah。然后呢，我重点讲了几种实现密等操作的方法，你可以利用数据库的约束来防止重复的更新数据，也可以呢为数据更新设置一个一次性的前置条线来防止重复消息。如果说啊这两种方法都不适用，你还可以用记录并检查操作这种方法来保证密等。这种方法呢适用范围最广，但是呢实现难度和复杂度呢也比较高，一般来说啊不推荐你使用。那这些实现密等的方法不仅可以。用来解决重复消费的问题，也同样适合用于其他的场景中来解决重复请求或者是重复调用的问题。比如说啊我们可以把HTTP服务啊设计成密等的，解决前端或者app重复提交表单数据的问题，也可以将一个微服务设计成密等的，来解决RPC框架，它会自动重试，导致重复调用的问题，这些方法都是通用的，希望你能做到触类旁通，举一反三。最后请你想一下，为什么大部分的消息队列啊，它都。选择只提供at least once的服务质量，而不是级别更高的exactly once呢。欢迎你在留言区与我分享和讨论，感谢你的聆听。如果你觉得这篇文章对你有帮助的话，也欢。😊"
  },
  {
    "id": "1765424349469",
    "title": "未命名面试 57",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "已完成",
    "date": "2025-12-11T03:39",
    "fileUrl": "uploads/usr_ed4ebf18/ddf23665-c8e1-4cc8-a2e7-8aec6fdde50f.mp3",
    "fileType": "audio/mpeg",
    "durationSeconds": 839.57551,
    "durationText": "14分",
    "transcriptText": "你好，我是李悦。上节课啊我们讲了如何来确保消息不丢。那课后呢我给你留了一个思考题，让你想一下，如果说消息重复了应该怎么办。那这节课呢我们就来聊一聊如何来处理重复消息的问题。.在消息传递的过程中啊，如果出现了传递失败，发送方呢他会执行重试，那重试的过程中就可能会产生重复消息。对使用消息对列的业务系统来说啊，如果你没有对重复的消息进行处理。那就有可能会导致系统出现数据错误。比如说啊一个消费订单消息统计下单金额服务的微服务。如果他没有正确的处理这个重复消息，那就会出现重复统计，导致这个统计结果错误。那你可能。会问啊，如果消息队列本身能保证消息不重复，那应用程序的实现不就简单了吗？那有没有消息队列能够保证消息不重复呢？关于这个问题啊，我们可以先看一下MQTT协议它是如何界定的。在MQTT协议里边啊，它给出了三种传递消息的时候，能够提供的服务质量标准。这三种服务质量标准从低到高，依次是至多一次至少一次以及恰好一次。我来分别解释一下啊，首先是至多一次。那在MQTT里边呢被称为。most once意思是啊，消息在传递的时候最多会被送达一次。那换一个说法就是没有什么消息可靠性保证他允许丢消息。一般啊都是一些对消息可靠性要求不太高的监控场景。比如说啊我每分钟上报一次机房温度数据，那它是可以接受少量数据丢失的。然后啊我们看一下至少一次这个标准，也就是at least once消息在传递的时候啊，至少会被送达一次，也就是说啊它不允许丢消息，但是允许呢有少量的重复消息出现，最后啊也就是最高的等级，就是恰好一次exactly once。那消息在传递的时候呢，只会被送达一次，不允许丢失，也不允许重复这个标准啊，它不仅仅适用于MQTT啊。那对于所有的消息队列啊，它都是适用的。我们现在常用的绝大部分的消息队列，它提供的服务质量标准啊都是at least once。那包括rocket mQrabbit mQ和卡夫卡都是这样的。也就是说啊，消息队列，它很难保证消息不重复。说到这儿啊，我知道肯定有同学会反驳我我说你说的不对，我看过卡夫卡的文档，卡夫卡呢它是支持exactly once的那我在这里呢跟这些同学解释一下啊，你说的没错，卡夫卡呢的确是支持exactly once。但是啊我讲的也没有问题，为什么这么说呢？卡夫卡它支持的exactly once啊和我们刚刚提到的消息传递的服务质量标准中的exactly once啊，它是不一样的。它是卡夫卡提供的另外一个特性。Yeah.卡普卡中啊支持的事物也和我们通常意义理解的事物啊有一定差异。在卡普卡里边啊，事物和exactly once，它主要是为了配合流计算而使用的特性。我们在专栏的进阶篇这个模块里边啊，会有专门的一节课来讲卡普卡的事物和它支持的exactly once的特性。说到这里啊，稍微说一些题外话，卡普卡的团队啊是一个非常善于包装和营销的团队。你看它很巧妙的利用了两个所有人都熟悉的概念。事物。exactly once来包装它的新特性。实际上它实现的这个事物和exactly once啊，并不是我们通常理解的那两个特性。但是啊你深入了解开发的事物和exly once之后呢，你会发现啊，其实它这个特性啊，虽然跟我们通常理解的这个不太一样。但是啊确实和事物和exly once呢有一定关系，这一点上啊我们都要学习开发团队啊，那一个优秀的开发团队啊，你不仅要能写代码，那你更要能写文档，还能写PPT还要。😊能讲会分享。对于每个程序人来说啊，要求也是一样的。我们把话题收回来啊，继续来说重复消息的问题。既然啊你消息队列啊不能保证消息不重复，那就需要我们的消费代码能够接受消息是有可能重复这个现状。然后啊通过一些方法来消除重复消息对业务的影响。一般解决重复消息的办法是啊，在消费端啊让我们消费消息的这个操作啊具有密等性。密等这个词啊，本来它是一个数学上的概念，有明确的数学定义。那这个定义呢是个数学公式，我就不念了。听音频的同学啊，可以听完之后啊，再看一下这个公式。这个概念啊被拓展到计算机的领域，被用来描述一个操作方法或者服务。一个密等操作，它的特点是任意多次执行所产生的影响，均与一次执行产生的影响一样。通俗的说啊，一个密等的方法，我们使用同样的参数，对它进行多次的调用和一次调用，那对系统产生的影响应该是一样的。所以啊对于密等的方法不用担心重复执行，会对系统造。任何改变。我们来举个例子说明一下啊，在不考虑并发的情况下，把账户X的余额设置为100元。这个操作它执行一次以后啊，对系统的影响是账户X的余额变成100元了。那只要这个参数100元不变啊。那即使再执行多少次。那你账户X，它的余额始终都是100元，不会变化。那这个操作呢，它就是一个密等的操作，我再给你举一个不是密等的例子啊，把账户X。的余额加100元。注意啊，这个例子里边啊是加100元，不是设置为100元。那这个操作呢它就不是密等的。我们每执行一次啊，你的账户余额呢它就会多100元，那执行多次和执行一次，对系统的影响，也就是账户余额它是不一样的。如果说啊我们系统消费消息的业务逻辑具备密等性，那就不用担心重复消息的问题。因为啊同一条消息啊，消费一次和消费多次，那对系统的影响。讲是完全一样的那也就可以认为啊消费多次啊等于消费一次。从对系统的影响结果来说啊，这个act least once加上密等消费啊，就等于是exactly once。那到底怎么来实现这个密等呢？最好的方法啊，其实是你从业务逻辑上入手，把消费的业务逻辑啊设计成天然幂等的。😊あ。但是啊不是所有的业务逻辑啊，都能设计成天然密等的。这里面啊就需要一些方法和技巧来实现密等。下面啊我给你介绍几种常用的设计密等操作的方法。那第一种方法就是啊利用数据库的约束来实现密等。比如说啊我刚刚提到的那个不具备密等特性的转账的例子，把账户X的余额加100元。我们可以这样来改造这个业务逻辑啊，让它具备密等性。首先啊我们可以限定对于每一个转账单。？每一个账户它只能执行一次变更操作。那在分布式系统里边呢，这个限制的实现方法非常多。最简单的方法是我们在数据库里边啊建一张转账流水表。这个表呢有三个字段，第一个字段呢是转账单ID第二个字段呢是账户ID第三个字段呢是变更的金额。然后啊我们给转账单ID和账户ID这两个字段联合起来，创建一个唯一约束。这样对于相同的转账单ID和账。用户ID表里边呢最多只能存在一条记录。然后啊我们可以把消费消息的业务逻辑啊变成这样。我们现在转账的流水表里边呢加一条转账记录，然后啊再根据转账记录里边记录的转账金额，一步的来操作更新用户的余额就可以了。那在转账流水表里边增加一条转账记录这个操作，由于啊我们在这个表里边预先定义了唯一的约束。那对于同一个转账单，同一个账户，它只能查。入一条记录，那后续重复的插入操作呢都会失败。这样呢就实现了一个密等的操作。我们只要写一个 circlecle，正确的实现它的就可以了。基于这个思路啊，不光可以使用关型数据库。只要是支持类似insertif not exist语义的这类存储系统都可以用来实现密等。比如说啊你可以用radis的s NX命令来替代数据库的唯一约束，实现这个消费密等。另外一个实现密等的思路啊，它是这样的。.我们可以给数据变更呢设置一个前置条件，只有满足条件的时候呢，才更新数据，否则呢就拒绝更新这个数据。同时啊我们在更新数据的时候呢，会变更这个前置条件需要判断的数据。这样啊在重复执行这个操作的时候啊，由于第一次更新数据的时候呢，已经变更了这个前置条件中需要判断的数据。那不满足前置条件呢，这个重复执行呢就不会更新数据。比如啊我们刚刚说过啊，把账户X的余额加。加100元这个操作啊，它本来是不具备密等的特性的那我们呢可以把这个操作给它加一个前置条件，变成如果账户X当前的余额为500元，那就给它的余额加上100元。这个操作啊它就具备密等性。对应到消息队列使用的时候啊，可以在发消息的时候呢，在消息体中带上当前的余额，那在消费的时候呢，判断数据库中，当前的余额是否与消息体中的余额一样。只有相等的时候啊，才执行变更操作。那如果我们要更新的数据啊，它不是一个数值，或者说我们要做一个比较复杂的更新操作的时候怎么办呢？那用什么来做这个前置的判断条件呢？那更加通用的方法是这样的。你可以啊给你的数据啊增加一个版本号的属性。那每次在更新这个数据之前呢，比较一下当前数据的版本号是否和消息中带的这个版本号一样。如果一样呢，就可以更新。那如果不一样呢，就拒绝更新这个数据。并且啊更新数据的同时啊，你要把这个版本号加一，这样一样可以实现密等更新。嗯。如果啊上面提到的这两种密等方法，都不能适用于你的场景啊。我们还有一种通用性最强、适用范围最广的密等方法。那这种方法呢叫记录并检查操作，那也称为token机制，或者是全局为EID的机制。Yeah.实现的思路呢也很简单。那你在执行数据更新操作之前呢，先检查一下是否执行过这个更新操作就可以了。具体的实验方法是这样的，在发消息的时候啊，给每一个消息指定一个全局唯一的ID那在消费的时候呢，先根据这个ID来检查一下这条消息啊，有没有被消费过。如果说没有被消费过呢，你才去执行这个数据更新。同时呢把这个消费状态呢设置为已消费这个原理和实现是不是很简单啊。其实一点儿都不简单，在分布式系统中啊，这个方法其实是非常难实现的。首先啊给每个消息指定一个全局为1ID这件事啊就不太容易。虽然啊方法有很多，但是啊都不太好，同时的满足简单高可用和高性能，或多或少的都会有些牺牲，这还不是更麻烦的，更麻烦的是什么啊？就是啊检查消费状态，然后更新数据，并且啊设置消费状态，这个过程中啊。😊这三个步骤啊，它必须作为一种操作来保证原子性，才能真正的实现密等，否则啊就会出现bug。比如说啊对于一条消息，它的全局ID为8，那它的操作呢是给ID为666的账户增加100元。あ。那有可能就会出现这样的情况。在T0时刻啊，消费者A他收到了这条消息，然后呢，他去检查消费执行的状态，发现这个状态呢是未处理。然后呢，他开始执行账户增加100元这个操作到了T一时刻啊，消费者B啊又收到了这条消息，然后呢，他去检查执行状态，发现呢还是未处理过。因为这个时刻啊消费者A还没来得及更新这个消息执行状态。。这样就会导致账户啊被错误的增加了两次100元。这个呢是在分布式系统中啊非常容易犯的错误。那你一定要引以为戒。对于这个问题啊，当然啊我们还可以用事物来实现，也可以用锁来实现。但是啊在分布式系统中啊，无论是分布式事务还是分布式锁啊，都是比较难解决的问题。好的，这就是今天的全部内容，我来总结一下啊，这节课啊我们主要介绍了通过密等消费来解决重复消息的问题。😊は。然后呢，我重点讲了几种实现密等操作的方法，你可以利用数据库的约束来防止重复的更新数据，也可以呢为数据更新设置一个一次性的前置条线来防止重复消息。如果说啊这两种方法都不适用，你还可以用记录并检查操作这种方法来保证密等。这种方法呢适用范围最广，但是呢实现难度和复杂度呢也比较高，一般来说啊不推荐你使用。那这些实现密等的方法不仅可以。用来解决重复消费的问题，也同样适合用于其他的场景中来解决重复请求或者是重复调用的问题。比如说啊我们可以把HTTP服务啊设计成密等的，解决前端或者app重复提交表单数据的问题，也可以将一个微服务设计成密等的，来解决RPC框架，它会自动重试，导致重复调用的问题，这些方法都是通用的，希望你能做到触类旁通，举一反三。最后请你想一下，为什么大部分的消息队列啊它都。选择只提供at least once的服务质量，而不是级别更高的exactly once呢。欢迎你在留言区与我分享和讨论，感谢你的聆听。如果你觉得这篇文章对你有帮助的话，也欢。😊"
  },
  {
    "id": "1765424324869",
    "title": "未命名面试 56",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "已完成",
    "date": "2025-12-11T03:38",
    "fileUrl": "uploads/usr_ed4ebf18/5c1d0693-9481-4119-8390-68c6e9680ecf.mp3",
    "fileType": "audio/mpeg",
    "durationSeconds": 645.01551,
    "durationText": "10分45秒",
    "transcriptText": "你好，我是李悦。在对专栏的内容正式学习之前啊，我想先来聊聊如何学习消息队列以及如何学习这门课。从系统之间有通讯需求的那一刻开始呢，就产生了消息队列，它也是最古老的中间件之一。消息队列的应用场景啊非常广泛。分布式系统中的很多进程间通信的问题，你都可以用消息队列来解决。可以说啊消息队列是所有的后端程序员必备的技能，但是啊想要系统的。😊深入的学习消息队列也不太容易。在市面上消息队列的论坛啊、社区啊都不少。但是啊信息错综混杂，你想要了解消息队列完整的知识体系，想要深度的进阶成为消息队列的达人，却没有清晰的学习路。"
  },
  {
    "id": "1765424280370",
    "title": "未命名面试 55",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "已完成",
    "date": "2025-12-11T03:38",
    "fileUrl": "uploads/usr_ed4ebf18/7917e212-1278-4a07-bc31-1ed6d77f12e1.mp3",
    "fileType": "audio/mpeg",
    "updatedAt": "2025-12-11T03:38:06.521054"
  },
  {
    "id": "1765423766563",
    "title": "未命名面试 54",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "待上传",
    "date": "2025-12-11T03:29"
  },
  {
    "id": "1765423766114",
    "title": "未命名面试 53",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "待上传",
    "date": "2025-12-11T03:29"
  },
  {
    "id": "1765423760664",
    "title": "未命名面试 52",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "待上传",
    "date": "2025-12-11T03:29"
  },
  {
    "id": "1765423735463",
    "title": "未命名面试 51",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "已完成",
    "date": "2025-12-11T03:28"
  },
  {
    "id": "1765423727529",
    "title": "未命名面试 50",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "待上传",
    "date": "2025-12-11T03:28"
  },
  {
    "id": "1765423615030",
    "title": "未命名面试 49",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "已上传文件",
    "date": "2025-12-11T03:26",
    "fileUrl": "uploads/usr_ed4ebf18/a1c7ca4b-1cbe-4dcc-ab44-8afef57139d1.mp3",
    "fileType": "audio/mpeg",
    "durationSeconds": 645.01551,
    "durationText": "10分45秒"
  },
  {
    "id": "1",
    "title": "未命名面试 48",
    "company": "未知公司",
    "position": "未知岗位",
    "status": "待上传",
    "date": "2025-12-08T14:30"
  },
  {
    "id": "2",
    "title": "字节跳动前端一面",
    "company": "字节跳动",
    "position": "前端开发工程师",
    "status": "已完成",
    "date": "2024-03-15T14:00"
  },
  {
    "id": "3",
    "title": "腾讯技术面",
    "company": "腾讯",
    "position": "后端开发",
    "status": "已完成",
    "date": "2025-12-03T10:30"
  },
  {
    "id": "4",
    "title": "阿里巴巴二面",
    "company": "阿里巴巴",
    "position": "算法工程师",
    "status": "已完成",
    "date": "2025-12-01T16:00"
  }
]